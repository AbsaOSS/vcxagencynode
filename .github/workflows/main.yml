name: CI

on:
  push:
    branches:
      - master
  pull_request:
    branches:
      - "**"

jobs:
  workflow-setup:
    runs-on: ubuntu-latest
    outputs:
      CACHE_KEY_BASE: ${{ steps.mainstep.outputs.CACHE_KEY_BASE }}
      CACHE_KEY_AGENCY: ${{ steps.mainstep.outputs.CACHE_KEY_AGENCY }}
      CACHE_KEY_REDIS: ${{ steps.mainstep.outputs.CACHE_KEY_REDIS }}
      CACHED_DOCKER_IMG_NAME_BASE: ${{ steps.mainstep.outputs.CACHED_DOCKER_IMG_NAME_BASE }}
      CACHED_DOCKER_IMG_NAME_AGENCY: ${{ steps.mainstep.outputs.CACHED_DOCKER_IMG_NAME_AGENCY }}
      CACHED_DOCKER_IMG_NAME_REDIS: ${{ steps.mainstep.outputs.CACHED_DOCKER_IMG_NAME_REDIS }}
      PUBLISH_DOCKER_IMG_NAME_AGENCY: ${{ steps.mainstep.outputs.PUBLISH_DOCKER_IMG_NAME_AGENCY }}
      PUBLISH_DOCKER_IMG_NAME_REDIS: ${{ steps.mainstep.outputs.PUBLISH_DOCKER_IMG_NAME_REDIS }}
      PUBLISH_VERSION: ${{ steps.mainstep.outputs.PUBLISH_VERSION }}
      RELEASE: ${{ steps.mainstep.outputs.RELEASE }}
      PRERELEASE: ${{ steps.mainstep.outputs.PRERELEASE }}
    steps:
      - run: echo $GITHUB_REF
      - run: echo $GITHUB_HEAD_REF
      - run: echo $GITHUB_BASE_REF
      - run: echo $GITHUB_WORKSPACE
      - run: echo $GITHUB_EVENT_NAME
      - run: echo $GITHUB_RUN_NUMBER
      - run: echo $GITHUB_RUN_ID
      - name: Git checkout
        uses: actions/checkout@v1
      - name: Set outputs
        id: mainstep
        run: |
          set -x

          if [[ -z "$GITHUB_HEAD_REF" ]]; then # is set only if pipeline run is triggered as pull request
            BRANCH_NAME="${GITHUB_REF#refs/heads/}"
            echo "Setting BRANCH_NAME=$BRANCH_NAME because this pipeline is run as Push"
          else
            BRANCH_NAME=$GITHUB_HEAD_REF
            echo "Setting BRANCH_NAME=$BRANCH_NAME because this pipeline is run as Pull Request"
          fi

          BRANCH_NAME=`echo $BRANCH_NAME | sed "s/[^[:alnum:]-]//g" | tr '[:upper:]' '[:lower:]'` # lowercase, only alphanumeric and dash

          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            echo "PR Labels: ${{ toJson(github.event.pull_request.labels.*.name) }}"

            REPO_HEAD="${{ github.event.pull_request.head.repo.full_name }}" # source repository
            REPO_BASE="${{ github.event.pull_request.head.base.full_name }}" # target repository
            echo "This is pull request from $REPO_HEAD to $REPO_BASE"

            if [[ "$REPO_HEAD" == "${{ github.repository }}" ]]; then
              echo "This CI run is PR from non-forked repository."
              IS_FORK="false";
            else
              echo "This is fork."
              IS_FORK="true";
            fi;
          else
            echo "Not PR so this is not fork."
            IS_FORK="false";
          fi;

          REPO_VERSION_MOST_RECENT=$(git describe --tags --always --abbrev=0)
          REPO_VERSION_DESIRED=`bash ./get-version.sh`
          echo "Highest released version was: $REPO_VERSION_MOST_RECENT, desired version (specified in libvcx/Cargo.toml) is $REPO_VERSION_DESIRED"

          RELEASE="false"
          PRERELEASE="false"

          if [[ "$IS_FORK" == "false" ]]; then
            if [[ "${{ github.event_name }}" == "pull_request" ]]; then
              if [[ "${{ contains(github.event.pull_request.labels.*.name, 'pre-release') }}" == "true" ]]; then
                PRERELEASE="true"
              fi;
            elif [[ "${{ github.event_name }}" == "push" ]]; then
              if [[ "$BRANCH_NAME" == "master" && "$REPO_VERSION_DESIRED" != "$REPO_VERSION_MOST_RECENT" ]]; then
                PUBLISH_VERSION="$REPO_VERSION_DESIRED"
                RELEASE="true"
                echo "This is push to master, and version was bumped from $REPO_VERSION_MOST_RECENT to $REPO_VERSION_DESIRED. Will publish a release of $REPO_VERSION_DESIRED."
              fi;
            fi;

            if [[ -z "$PUBLISH_VERSION" ]]; then
              PUBLISH_VERSION="$REPO_VERSION_MOST_RECENT-$BRANCH_NAME-${{ github.run_number }}"
            fi;

            echo "CI will publish artifacts at version: $PUBLISH_VERSION"
          else
            echo "This PR is from fork, nothing will be published because the CI wouldn't be able to access repo secrets to perform publish."
            PUBLISH_VERSION=""
          fi;

          export DOCKER_BASE_HASH=${{ hashFiles('vcxagency-base') }}
          export CODE_AGENCY_HASH=${{ hashFiles('vcxagency-node') }}
          export CODE_EASYSDK_HASH=${{ hashFiles('easy-indysdk') }}
          export CODE_CLIENT_HASH=${{ hashFiles('vcxagency-client') }}

          echo "::set-output name=CACHE_KEY_BASE::$DOCKER_BASE_HASH"
          echo "::set-output name=CACHE_KEY_AGENCY::$(echo basehash-$CACHE_KEY_BASE-agencyhash-$CODE_AGENCY_HASH-clienthash-$CODE_CLIENT_HASH-easyindysdkhash-$CODE_EASYSDK_HASH)"
          echo "::set-output name=CACHE_KEY_REDIS::${{ hashFiles('ci/redis') }}"
          echo "::set-output name=CACHED_DOCKER_IMG_NAME_BASE::vcxagency-base:cached"
          echo "::set-output name=CACHED_DOCKER_IMG_NAME_AGENCY::vcxagency-node:cached"
          echo "::set-output name=CACHED_DOCKER_IMG_NAME_REDIS::redis:cached"

          echo "::set-output name=PUBLISH_DOCKER_IMG_NAME_AGENCY::vcxagency-node:$PUBLISH_VERSION"
          echo "::set-output name=PUBLISH_DOCKER_IMG_NAME_REDIS::vcxagency-redis:$PUBLISH_VERSION"

          echo "::set-output name=PUBLISH_VERSION::$PUBLISH_VERSION"
          echo "::set-output name=PRERELEASE::$PRERELEASE"
          echo "::set-output name=RELEASE::$RELEASE"


  build-vcxagency-base:
    needs:
      - workflow-setup
    runs-on: ubuntu-latest
    env:
      DOCKER_BUILDKIT: 1
      CACHE_KEY_BASE: ${{needs.workflow-setup.outputs.CACHE_KEY_BASE}}
      CACHED_DOCKER_IMG_NAME_BASE: ${{needs.workflow-setup.outputs.CACHED_DOCKER_IMG_NAME_BASE}}
    steps:
      - name: Git checkout
        uses: actions/checkout@v2
      - name: Try load from cache.
        id: cache-image
        uses: actions/cache@v2
        with:
          path: /tmp/imgcache
          key: ${{ env.CACHE_KEY_BASE }}
      - name: If NOT found in cache, Build and cache image.
        if: steps.cache-image.outputs.cache-hit != 'true'
        run: |
          vcxagency-base/build.sh "$CACHED_DOCKER_IMG_NAME_BASE"
          mkdir -p /tmp/imgcache
          docker save "$CACHED_DOCKER_IMG_NAME_BASE" > /tmp/imgcache/img_base.rar
          docker image ls

  build-vcxagency-redis:
    needs:
      - workflow-setup
    runs-on: ubuntu-latest
    env:
      DOCKER_BUILDKIT: 1
      CACHE_KEY_REDIS: ${{needs.workflow-setup.outputs.CACHE_KEY_REDIS}}
      CACHED_DOCKER_IMG_NAME_REDIS: ${{needs.workflow-setup.outputs.CACHED_DOCKER_IMG_NAME_REDIS}}
    steps:
      - name: Git checkout
        uses: actions/checkout@v2
      - name: Try load from cache.
        id: cache-image
        uses: actions/cache@v2
        with:
          path: /tmp/imgcache
          key: ${{ env.CACHE_KEY_REDIS }}
      - name: If NOT found in cache, Build and cache image.
        if: steps.cache-image.outputs.cache-hit != 'true'
        run: |
          set -x
          docker build -t "$CACHED_DOCKER_IMG_NAME_REDIS" ci/redis
          mkdir -p /tmp/imgcache
          docker save "$CACHED_DOCKER_IMG_NAME_REDIS" > /tmp/imgcache/image.rar
          docker image ls

  build-image-vcxagency:
    runs-on: ubuntu-latest
    needs:
      - workflow-setup
    env:
      DOCKER_BUILDKIT: 1
      CACHE_KEY_BASE: ${{needs.workflow-setup.outputs.CACHE_KEY_BASE}}
      CACHE_KEY_AGENCY: ${{needs.workflow-setup.outputs.CACHE_KEY_AGENCY}}
      CACHED_DOCKER_IMG_NAME_BASE: ${{needs.workflow-setup.outputs.CACHED_DOCKER_IMG_NAME_BASE}}
      CACHED_DOCKER_IMG_NAME_AGENCY: ${{needs.workflow-setup.outputs.CACHED_DOCKER_IMG_NAME_AGENCY}}
    steps:
      - name: Load base image cache
        id: load-cached-image-base
        uses: actions/cache@v2
        with:
          path: /tmp/imgcache
          key: ${{ env.CACHE_KEY_BASE }}

      - name: If no cached image found
        if: steps.load-cached-image-base.outputs.cache-hit != 'true'
        run: echo "ERROR == Expected to find image from cache $CACHE_KEY_BASE"; exit -1

      - name: Load base image
        run: docker load < /tmp/imgcache/img_base.rar

      - name: Verify base image was loaded
        run: docker image ls --format "{{.Repository}}:{{.Tag}}" | grep "$CACHED_DOCKER_IMG_NAME_BASE" || { echo "Image $CACHED_DOCKER_IMG_NAME_BASE was not found!"; docker image ls; exit 1; }

      - name: Load base image cache
        id: load-cached-image-node
        uses: actions/cache@v2
        with:
          path: /tmp/imgcache
          key: ${{ env.CACHE_KEY_AGENCY }}
      - name: Git checkout
        uses: actions/checkout@v2
      - name: If no cached image found, build and save to cache
        if: steps.load-cached-image-node.outputs.cache-hit != 'true'
        run: |
          set -x
          echo "Cache miss for key ${{ env.CACHE_KEY_AGENCY }} No image was found. Let's build it!"
          docker build \
                       --build-arg AGENCY_BASE_IMAGE="$CACHED_DOCKER_IMG_NAME_BASE" \
                       -f vcxagency-node/Dockerfile \
                       -t "$CACHED_DOCKER_IMG_NAME_AGENCY" \
                        .
          mkdir -p /tmp/imgcache
          docker save "$CACHED_DOCKER_IMG_NAME_AGENCY" > /tmp/imgcache/img_agency.rar
          docker image rm "$CACHED_DOCKER_IMG_NAME_AGENCY"

      - name: Load agency image from cache
        run: |
          docker load < /tmp/imgcache/img_agency.rar
      - name: Verify agency image was loaded
        run: |
          docker image ls --format "{{.Repository}}:{{.Tag}}" | grep "$CACHED_DOCKER_IMG_NAME_AGENCY" || { echo "Image $CACHED_DOCKER_IMG_NAME_AGENCY was not found!"; docker image ls; exit 1; }


  test-unit-vcxagency:
    runs-on: ubuntu-latest
    needs:
      - build-image-vcxagency
      - workflow-setup
    env:
      CACHE_KEY_AGENCY: ${{needs.workflow-setup.outputs.CACHE_KEY_AGENCY}}
      CACHED_DOCKER_IMG_NAME_AGENCY: ${{needs.workflow-setup.outputs.CACHED_DOCKER_IMG_NAME_AGENCY}}
      CACHE_KEY_REDIS: ${{needs.workflow-setup.outputs.CACHE_KEY_REDIS}}
      CACHED_DOCKER_IMG_NAME_REDIS: ${{needs.workflow-setup.outputs.CACHED_DOCKER_IMG_NAME_REDIS}}
    steps:
      - name: Git checkout
        uses: actions/checkout@v2
      - name: Load agency image cache
        id: load-cached-image-node
        uses: actions/cache@v2
        with:
          path: /tmp/imgcache
          key: ${{ env.CACHE_KEY_AGENCY }}

      - name: If no cached image found -> ERROR
        if: steps.load-cached-image-node.outputs.cache-hit != 'true'
        run: echo "ERROR == Expected to find image from cache $CACHE_KEY_AGENCY"; exit -1

      - name: Load agency image from cache
        run: docker load < /tmp/imgcache/img_agency.rar

      - name: Verify agency image was loaded
        run: docker image ls --format "{{.Repository}}:{{.Tag}}" | grep "$CACHED_DOCKER_IMG_NAME_AGENCY" || { echo "Image $CACHED_DOCKER_IMG_NAME_AGENCY was not found!"; docker image ls; exit 1; }

      - name: Load redis image cache
        id: load-cached-image-redis
        uses: actions/cache@v2
        with:
          path: /tmp/imgcache
          key: ${{ env.CACHE_KEY_REDIS }}

      - name: If no cached image found -> ERROR
        if: steps.load-cached-image-redis.outputs.cache-hit != 'true'
        run: echo "ERROR == Expected to find image from cache $CACHE_KEY_REDIS"; exit -1

      - name: Load Redis image from cache
        run: docker load < /tmp/imgcache/image.rar

      - name: Verify Redis image was loaded
        run: docker image ls --format "{{.Repository}}:{{.Tag}}" | grep "$CACHED_DOCKER_IMG_NAME_REDIS" || { echo "Image $CACHED_DOCKER_IMG_NAME_REDIS was not found!"; docker image ls; exit 1; }

      - name: Run tests
        run: |
          set -x
          docker image ls
          docker-compose -f ci/docker-compose.yml -f ci/docker-compose.pg.yml -f ci/docker-compose.redis.yml up -d
          sleep 5
          docker run --rm --name vcxagencynode \
                        --network host \
                         "$CACHED_DOCKER_IMG_NAME_AGENCY" \
                         bash -c "yarn install && yarn run test:unit"

  test-unit-easy-indysdk:
    runs-on: ubuntu-latest
    needs:
      - build-image-vcxagency
      - workflow-setup
    env:
      CACHE_KEY_AGENCY: ${{needs.workflow-setup.outputs.CACHE_KEY_AGENCY}}
      CACHED_DOCKER_IMG_NAME_AGENCY: ${{needs.workflow-setup.outputs.CACHED_DOCKER_IMG_NAME_AGENCY}}
    steps:
      - name: Load agency image cache
        id: load-cached-image-node
        uses: actions/cache@v2
        with:
          path: /tmp/imgcache
          key: ${{ env.CACHE_KEY_AGENCY }}

      - name: If no cached image found -> ERROR
        if: steps.load-cached-image-node.outputs.cache-hit != 'true'
        run: echo "ERROR == Expected to find image from cache $CACHE_KEY_AGENCY"; exit -1

      - name: Load agency image from cache
        run: docker load < /tmp/imgcache/img_agency.rar

      - name: Verify image was loaded
        run: docker image ls --format "{{.Repository}}:{{.Tag}}" | grep "$CACHED_DOCKER_IMG_NAME_AGENCY" || { echo "Image $CACHED_DOCKER_IMG_NAME_AGENCY was not found!"; docker image ls; exit 1; }

      - name: Run tests
        run: |
          set -x
          docker run --rm --name vcxagencynode \
                        --network host \
                         "$CACHED_DOCKER_IMG_NAME_AGENCY" \
                         bash -c "cd /home/node/easy-indysdk && yarn install && yarn run test:unit"

  test-unit-vcxagency-client:
    runs-on: ubuntu-latest
    needs:
      - build-image-vcxagency
      - workflow-setup
    env:
      CACHE_KEY_AGENCY: ${{needs.workflow-setup.outputs.CACHE_KEY_AGENCY}}
      CACHED_DOCKER_IMG_NAME_AGENCY: ${{needs.workflow-setup.outputs.CACHED_DOCKER_IMG_NAME_AGENCY}}
    steps:
      - name: Load agency image cache
        id: load-cached-image-node
        uses: actions/cache@v2
        with:
          path: /tmp/imgcache
          key: ${{ env.CACHE_KEY_AGENCY }}

      - name: If no cached image found -> ERROR
        if: steps.load-cached-image-node.outputs.cache-hit != 'true'
        run: echo "ERROR == Expected to find image from cache $CACHE_KEY_AGENCY";exit -1

      - name: Load agency image from cache
        run: docker load < /tmp/imgcache/img_agency.rar

      - name: Verify image was loaded
        run: docker image ls --format "{{.Repository}}:{{.Tag}}" | grep "$CACHED_DOCKER_IMG_NAME_AGENCY" || { echo "Image $CACHED_DOCKER_IMG_NAME_AGENCY was not found!"; docker image ls; exit 1; }

      - name: Run tests
        run: |
          set -x
          docker run --rm --name vcxagencynode \
                        --network host \
                         "$CACHED_DOCKER_IMG_NAME_AGENCY" \
                         bash -c "cd /home/node/vcxagency-client && yarn install && yarn run test:unit"

  test-e2e-vcxagency:
    runs-on: ubuntu-latest
    needs:
      - build-image-vcxagency
      - workflow-setup
    env:
      CACHE_KEY_AGENCY: ${{needs.workflow-setup.outputs.CACHE_KEY_AGENCY}}
      CACHE_KEY_REDIS: ${{needs.workflow-setup.outputs.CACHE_KEY_REDIS}}
      CACHED_DOCKER_IMG_NAME_AGENCY: ${{needs.workflow-setup.outputs.CACHED_DOCKER_IMG_NAME_AGENCY}}
      CACHED_DOCKER_IMG_NAME_REDIS: ${{needs.workflow-setup.outputs.CACHED_DOCKER_IMG_NAME_REDIS}}
    steps:
      - name: Load agency image cache
        id: load-cached-image-node
        uses: actions/cache@v2
        with:
          path: /tmp/imgcache
          key: ${{ env.CACHE_KEY_AGENCY }}

      - name: If no cached image found -> ERROR
        if: steps.load-cached-image-node.outputs.cache-hit != 'true'
        run: echo "ERROR == Expected to find image from cache $CACHE_KEY_AGENCY";exit -1

      - name: Load agency image from cache
        run: docker load < /tmp/imgcache/img_agency.rar

      - name: Verify image was loaded
        run: docker image ls --format "{{.Repository}}:{{.Tag}}" | grep "$CACHED_DOCKER_IMG_NAME_AGENCY" || { echo "Image $CACHED_DOCKER_IMG_NAME_AGENCY was not found!"; docker image ls; exit 1; }

      - name: Load redis image cache
        id: load-cached-image-redis
        uses: actions/cache@v2
        with:
          path: /tmp/imgcache
          key: ${{ env.CACHE_KEY_REDIS }}

      - name: If no cached image found -> ERROR
        if: steps.load-cached-image-redis.outputs.cache-hit != 'true'
        run: echo "ERROR == Expected to find image from cache $CACHE_KEY_REDIS"; exit -1

      - name: Load Redis image from cache
        run: docker load < /tmp/imgcache/image.rar

      - name: Verify Redis image was loaded
        run: docker image ls --format "{{.Repository}}:{{.Tag}}" | grep "$CACHED_DOCKER_IMG_NAME_REDIS" || { echo "Image $CACHED_DOCKER_IMG_NAME_REDIS was not found!"; docker image ls; exit 1; }

      - name: Git checkout
        uses: actions/checkout@v2

      - name: Run client agency services
        run: |
          set -x
          export AGENCY_IMAGE="$CACHED_DOCKER_IMG_NAME_AGENCY"
          docker-compose -f ./ci/docker-compose.yml \
                         -f ./ci/docker-compose.agency-ca.yml \
                         -f ./ci/docker-compose.pg.yml \
                         -f ./ci/docker-compose.redis.yml up -d
          sleep 5
          docker-compose -f ./ci/docker-compose.yml \
                         -f ./ci/docker-compose.agency-ca.yml \
                         -f ./ci/docker-compose.pg.yml \
                         -f ./ci/docker-compose.redis.yml logs

      - name: E2E Test client agency
        run: |
          set -x
          docker run --rm --name vcxagencynode \
                         --network host \
                         "$CACHED_DOCKER_IMG_NAME_AGENCY" \
                         bash -c "cd /home/node/vcxagency-client && yarn install && yarn run test:e2e:ca"

      - name: Stop docker containers
        run: |
          set -x
          export AGENCY_IMAGE="$CACHED_DOCKER_IMG_NAME_AGENCY"
          docker-compose -f ./ci/docker-compose.yml \
                         -f ./ci/docker-compose.agency-ca.yml \
                         -f ./ci/docker-compose.pg.yml \
                         -f ./ci/docker-compose.redis.yml \
                         down

      - name: Run enterprise agency services
        run: |
          set -x
          export AGENCY_IMAGE="$CACHED_DOCKER_IMG_NAME_AGENCY"
          docker-compose -f ./ci/docker-compose.yml \
                         -f ./ci/docker-compose.agency-ea.yml \
                         -f ./ci/docker-compose.pg.yml up -d
          sleep 5
          docker-compose -f ./ci/docker-compose.yml \
                         -f ./ci/docker-compose.agency-ea.yml \
                         -f ./ci/docker-compose.pg.yml logs

      - name: E2E Test enterprise agency
        run: |
          set -x
          docker run --rm --name vcxagencynode \
                         --network host \
                         "$CACHED_DOCKER_IMG_NAME_AGENCY" \
                         bash -c "cd /home/node/vcxagency-client && yarn install && yarn run test:e2e:ea"

  lint-vcxagency-node:
    runs-on: ubuntu-latest
    steps:
      - name: Git checkout
        uses: actions/checkout@v2
      - name: Install linter
        run: |
          sudo npm install -g standard@14.3.4
      - name: Lint
        run: |
          cd vcxagency-node && standard

  lint-vcxagency-client:
    runs-on: ubuntu-latest
    steps:
      - name: Git checkout
        uses: actions/checkout@v2
      - name: Install linter
        run: |
          sudo npm install -g standard@14.3.4
      - name: Lint
        run: |
          cd vcxagency-client && standard

  lint-easy-indysdk:
    runs-on: ubuntu-latest
    steps:
      - name: Git checkout
        uses: actions/checkout@v2
      - name: Install linter
        run: |
          sudo npm install -g standard@14.3.4
      - name: Lint
        run: |
          cd easy-indysdk && standard

  publish-images:
    needs:
      - workflow-setup
      - build-vcxagency-base
      - build-image-vcxagency
      - test-unit-vcxagency
      - test-e2e-vcxagency
      - test-unit-easy-indysdk
      - test-unit-vcxagency-client
      - lint-vcxagency-node
      - lint-vcxagency-client
      - lint-easy-indysdk
    runs-on: ubuntu-latest
    env:
      CACHE_KEY_AGENCY: ${{needs.workflow-setup.outputs.CACHE_KEY_AGENCY}}
      CACHE_KEY_REDIS: ${{needs.workflow-setup.outputs.CACHE_KEY_REDIS}}
      CACHED_DOCKER_IMG_NAME_AGENCY: ${{needs.workflow-setup.outputs.CACHED_DOCKER_IMG_NAME_AGENCY}}
      CACHED_DOCKER_IMG_NAME_REDIS: ${{needs.workflow-setup.outputs.CACHED_DOCKER_IMG_NAME_REDIS}}
      PUBLISH_DOCKER_IMG_NAME_AGENCY: ${{needs.workflow-setup.outputs.PUBLISH_DOCKER_IMG_NAME_AGENCY}}
      PUBLISH_DOCKER_IMG_NAME_REDIS: ${{needs.workflow-setup.outputs.PUBLISH_DOCKER_IMG_NAME_REDIS}}
    steps:
      - name: Load agency image cache
        id: load-cached-image-node
        uses: actions/cache@v2
        with:
          path: /tmp/imgcache
          key: ${{ env.CACHE_KEY_AGENCY }}

      - name: If no cached image found -> ERROR
        if: steps.load-cached-image-node.outputs.cache-hit != 'true'
        run: echo "ERROR == Expected to find image from cache $CACHE_KEY_AGENCY"; exit -1

      - name: Load agency image
        run: docker load < /tmp/imgcache/img_agency.rar

      - name: Verify images were loaded
        run: |
          docker image ls --format "{{.Repository}}:{{.Tag}}" | grep "$CACHED_DOCKER_IMG_NAME_AGENCY" || { echo "Image $CACHED_DOCKER_IMG_NAME_AGENCY was not found!"; docker image ls; exit 1; }


      - name: Load Redis image cache
        id: load-cached-image-redis
        uses: actions/cache@v2
        with:
          path: /tmp/imgcache
          key: ${{ env.CACHE_KEY_REDIS }}

      - name: If no cached image found -> ERROR
        if: steps.load-cached-image-redis.outputs.cache-hit != 'true'
        run: echo "ERROR == Expected to find image from cache $CACHE_KEY_REDIS"; exit -1

      - name: Load Redis image from cache
        run: docker load < /tmp/imgcache/image.rar

      - name: Verify Redis image was loaded
        run: docker image ls --format "{{.Repository}}:{{.Tag}}" | grep "$CACHED_DOCKER_IMG_NAME_REDIS" || { echo "Image $CACHED_DOCKER_IMG_NAME_REDIS was not found!"; docker image ls; exit 1; }


      - name: Docker Login
        uses: azure/docker-login@v1
        with:
          login-server: docker.pkg.github.com
          username: $GITHUB_ACTOR
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Publish images
        run: |
          GITHUB_REPOSITORY_LOWERCASE=`echo $GITHUB_REPOSITORY | awk '{print tolower($0)}'`
          REMOTE_DOCKER_IMG_NAME_AGENCY="docker.pkg.github.com/$GITHUB_REPOSITORY_LOWERCASE/$PUBLISH_DOCKER_IMG_NAME_AGENCY"
          REMOTE_DOCKER_IMG_NAME_REDIS="docker.pkg.github.com/$GITHUB_REPOSITORY_LOWERCASE/$PUBLISH_DOCKER_IMG_NAME_REDIS"
          docker tag "$CACHED_DOCKER_IMG_NAME_AGENCY" "$REMOTE_DOCKER_IMG_NAME_AGENCY"
          docker tag "$PUBLISH_DOCKER_IMG_NAME_REDIS" "$REMOTE_DOCKER_IMG_NAME_REDIS"
          docker image ls
          docker push "$REMOTE_DOCKER_IMG_NAME_AGENCY" || true
          docker push "$PUBLISH_DOCKER_IMG_NAME_REDIS" || true

  make-release:
    runs-on: ubuntu-16.04
    needs:
      - workflow-setup
      - build-vcxagency-base
      - build-image-vcxagency
      - test-unit-vcxagency
      - test-unit-easy-indysdk
      - test-unit-vcxagency-client
      - lint-vcxagency-node
      - lint-vcxagency-client
      - lint-easy-indysdk
    if: ${{ needs.workflow-setup.outputs.RELEASE == 'true' || needs.workflow-setup.outputs.PRERELEASE == 'true' }}
    outputs:
      RELEASE_UPLOAD_URL: ${{ steps.create-release.outputs.upload_url }}
    steps:
      - name: Git checkout
        uses: actions/checkout@v2

      - name: Generate changelog
        uses: heinrichreimer/github-changelog-generator-action@v2.2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          futureRelease: ${{ needs.workflow-setup.outputs.PUBLISH_VERSION }}
          releaseBranch: master
          pullRequests: true
          unreleased: true
          unreleasedOnly: true
          issuesWoLabels: true
          prWoLabels: true
          stripGeneratorNotice: true
          stripHeaders: false
          maxIssues: 50
          excludeLabels: duplicate,question,invalid,wontfix,changelog-excluded
          breakingLabels: backwards-incompatible,breaking
          deprecatedLabels: deprecated
          headerLabel: "# Changelog"
          breakingLabel: '### Breaking changes'
          enhancementLabel: '### Enhancements'
          bugsLabel: '### Bug fixes'
          deprecatedLabel: '###  Deprecations'
          removedLabel: '### Removals'
          securityLabel: '### Security fixes'
          issuesLabel: '### Other issues'
          prLabel: '### Other pull requests'
          addSections: '{"ci":{"prefix":"### CI changes","labels":["ci"]}}'
          excludeTagsRegex: '^((([0-9]+)\.([0-9]+)\.([0-9]+)(?:-([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))+)?)$'

      - name: Create a new release
        id: create-release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ needs.workflow-setup.outputs.PUBLISH_VERSION }}
          release_name: Release ${{ needs.workflow-setup.outputs.PUBLISH_VERSION }}
          body_path: ./CHANGELOG.md
          draft: ${{ needs.workflow-setup.outputs.PRERELEASE == 'true' }}
          prerelease: ${{ needs.workflow-setup.outputs.PRERELEASE == 'true' }}
